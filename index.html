<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GaggiMate Pro Profile Builder (Offline)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root {
      --bg: #020617;
      --bg-elevated: #020617;
      --border-subtle: #1f2937;
      --border-strong: #374151;
      --text: #e5e7eb;
      --text-muted: #9ca3af;
      --accent: #38bdf8;
      --accent-soft: #0ea5e9;
      --danger: #ef4444;
      --radius-lg: 1rem;
      --radius-md: 0.75rem;
      --radius-sm: 0.5rem;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #0f172a 0, #020617 55%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Inter", "Helvetica Neue", Arial, sans-serif;
    }

    body {
      min-height: 100vh;
    }

    main.page {
      max-width: 960px;
      margin: 0 auto;
      padding: 1rem clamp(1rem, 4vw, 1.5rem) 3.5rem;
    }

    header {
      margin-bottom: 1.25rem;
    }

    h1 {
      font-size: clamp(1.7rem, 4.2vw, 2.2rem);
      letter-spacing: 0.01em;
      margin: 0;
    }

    .subtitle {
      margin-top: 0.4rem;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    h2 {
      font-size: clamp(1.05rem, 3vw, 1.2rem);
      margin: 0 0 0.35rem;
    }

    .small {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .card {
      background: linear-gradient(135deg, #020617, #020617);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 1rem 1rem 1.1rem;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.55);
      margin-bottom: 1rem;
    }

    .card + .card {
      margin-top: 0.75rem;
    }

    label {
      display: block;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-strong);
      background: #020617;
      color: var(--text);
      font-size: 0.85rem;
    }

    input::placeholder,
    textarea::placeholder {
      color: #6b7280;
    }

    textarea {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
        Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      resize: vertical;
      min-height: 220px;
      white-space: pre;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent);
    }

    .field-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .field-row > div {
      flex: 1 1 120px;
      min-width: 0;
    }

    .field-row > .field-small {
      flex: 0 0 120px;
    }

    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-4 { margin-top: 1rem; }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.6rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      border-radius: 999px;
      border: 1px solid var(--border-strong);
      padding: 0.4rem 0.9rem;
      font-size: 0.82rem;
      background: #020617;
      color: var(--text);
      cursor: pointer;
      transition: background 0.12s ease, filter 0.12s ease,
        border-color 0.12s ease;
      white-space: nowrap;
    }

    .btn-sm {
      padding-block: 0.3rem;
      padding-inline: 0.7rem;
      font-size: 0.78rem;
    }

    .btn-primary {
      background: var(--accent-soft);
      border-color: var(--accent-soft);
      color: #f9fafb;
      font-weight: 500;
    }

    .btn-danger {
      background: #7f1d1d;
      border-color: #b91c1c;
      color: #fee2e2;
    }

    .btn-ghost {
      background: transparent;
      border-color: transparent;
      color: var(--text-muted);
    }

    .btn:hover {
      filter: brightness(1.08);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.1rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #111827;
      background: #020617;
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent-soft);
    }

    .chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #030712;
      font-size: 0.72rem;
      color: var(--text-muted);
    }

    .chart-wrapper {
      margin-top: 0.5rem;
      border-radius: var(--radius-md);
      background: radial-gradient(circle at top, #0b1120 0, #020617 70%);
      border: 1px solid #111827;
      padding: 0.4rem;
    }

    canvas {
      width: 100% !important;
      max-height: 260px;
    }

    /* --------- Phases as accordions --------- */

    .phases-list {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      margin-top: 0.4rem;
    }

    details.phase-card {
      border-radius: var(--radius-md);
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top left, #020617 0, #020617 55%);
      overflow: hidden;
    }

    details.phase-card[open] {
      border-color: var(--accent-soft);
    }

    .phase-summary {
      list-style: none;
      padding: 0.55rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      position: relative;
    }

    .phase-summary::-webkit-details-marker {
      display: none;
    }

    .phase-title {
      font-size: 0.9rem;
      font-weight: 500;
    }

    .phase-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      font-size: 0.72rem;
      color: var(--text-muted);
    }

    .phase-chevron {
      margin-left: auto;
      font-size: 0.8rem;
      color: var(--text-muted);
      transform: rotate(0deg);
      transition: transform 0.12s ease;
    }

    details[open] .phase-chevron {
      transform: rotate(90deg);
    }

    .phase-body {
      padding: 0.65rem 0.75rem 0.75rem;
      border-top: 1px solid #111827;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .phase-section-title {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 0.15rem;
    }

    .phase-section {
      border-radius: 0.65rem;
      background: #020617;
      border: 1px solid #111827;
      padding: 0.5rem 0.55rem 0.55rem;
    }

    /* ---- Stop-when targets UI ---- */

    .targets-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.4rem;
      margin-bottom: 0.25rem;
    }

    .targets-header-row .phase-section-title {
      margin-bottom: 0;
    }

    .targets-container {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .target-row {
      border-radius: 0.6rem;
      border: 1px solid #111827;
      padding: 0.4rem 0.55rem 0.5rem;
      background: #020617;
    }

    .target-row-header {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.25rem;
    }

    .target-row-header label {
      margin-bottom: 0;
      font-size: 0.72rem;
    }

    .target-row-header select {
      flex: 1;
      font-size: 0.82rem;
      padding: 0.3rem 0.45rem;
    }

    .target-row-body {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }

    .target-value-wrap {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .target-unit {
      font-size: 0.8rem;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .target-or {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin: 0.15rem 0;
    }

    .target-or-line {
      flex: 1;
      height: 1px;
      background: #111827;
    }

    .target-or-text {
      letter-spacing: 0.08em;
    }

    .targets-help {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.1rem;
    }

    .json-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    @media (max-width: 640px) {
      main.page {
        padding-inline: 0.75rem;
        padding-bottom: 2.75rem;
      }

      .card {
        border-radius: 0.85rem;
      }

      .phase-summary {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.2rem;
      }

      .phase-chevron {
        position: absolute;
        right: 0.75rem;
        top: 50%;
        transform: translateY(-50%);
      }

      .field-row > div,
      .field-row > .field-small {
        flex: 1 1 100%;
      }

      canvas {
        max-height: 220px;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>GaggiMate Pro Profile Builder</h1>
      <div class="subtitle">
        Build and tweak Pro profiles on your phone, then export JSON for GaggiMate.
      </div>
    </header>

    <!-- Profile header -->
    <section class="card">
      <h2>Profile</h2>
      <p class="small">
        Basic metadata and default brew temperature. Utility profiles are for rinses, backflush, etc.
      </p>

      <div class="field-row mt-2">
        <div>
          <label for="profile-label">Label</label>
          <input
            id="profile-label"
            type="text"
            placeholder="E.g. Ethiopian 1:2.5 flow profile"
          />
        </div>
        <div class="field-small">
          <label for="profile-type">Type</label>
          <select id="profile-type">
            <option value="pro">pro</option>
            <option value="basic">basic</option>
          </select>
        </div>
        <div class="field-small">
          <label for="profile-temp">Temp (Â°C)</label>
          <input id="profile-temp" type="number" step="0.1" />
        </div>
        <div class="field-small">
          <label for="profile-utility">Utility?</label>
          <select id="profile-utility">
            <option value="false">No (brew profile)</option>
            <option value="true">Yes (utility)</option>
          </select>
        </div>
      </div>

      <div class="mt-2">
        <label for="profile-description">Description</label>
        <input
          id="profile-description"
          type="text"
          placeholder="Notes about bean, ratio, etc."
        />
      </div>

      <div class="mt-3">
        <span class="pill">
          <span class="pill-dot"></span>
          Pro profile JSON (flow / pressure / weight)
        </span>
      </div>
    </section>

    <!-- Phases -->
    <section class="card">
      <h2>Phases</h2>
      <p class="small">
        Each phase has its own temperature override, pump mode, valve state, stop conditions
        (<strong>Stop whenâ€¦</strong>), and transition. Tap a phase to expand its full settings.
      </p>

      <div id="phases-list" class="phases-list"></div>

      <div class="btn-row mt-2">
        <button id="add-phase" class="btn btn-sm">+ Add phase</button>
        <button id="reset-profile" class="btn btn-sm btn-ghost">
          Reset to example profile
        </button>
      </div>
    </section>

    <!-- Brew curve -->
    <section class="card">
      <div style="display:flex;align-items:center;gap:0.5rem;">
        <div>
          <h2>Brew Curve Preview</h2>
          <p class="small">
            Pressure, flow, and temperature over time, derived from the phase settings.
          </p>
        </div>
        <span class="chip">Read-only simulation</span>
      </div>

      <div class="chart-wrapper">
        <canvas id="profile-chart"></canvas>
      </div>
    </section>

    <!-- JSON -->
    <section class="card">
      <h2 class="mt-1">Profile JSON</h2>
      <p class="small">
        This is the exported profile. It matches a GaggiMate <code>pro</code> profile; fields like
        <code>id</code>, <code>selected</code>, and <code>favorite</code> are intentionally omitted.
      </p>

      <textarea id="json-preview" readonly></textarea>

      <div class="json-actions">
        <button id="download-json" class="btn btn-primary">â¬‡ Download JSON</button>
        <button id="copy-json" class="btn">ðŸ“‹ Copy JSON</button>
      </div>
    </section>
  </main>

  <script>
    // --- Default profile from your machine ---
    const defaultProfile = {
      label: "Basic",
      type: "pro",
      description: "",
      temperature: 93,
      utility: false,
      phases: [
        {
          name: "Pump",
          phase: "preinfusion",
          valve: 1,
          duration: 3,
          temperature: 0,
          transition: { type: "instant", duration: 0, adaptive: true },
          pump: 100
        },
        {
          name: "Bloom",
          phase: "preinfusion",
          valve: 1,
          duration: 5,
          temperature: 0,
          transition: { type: "instant", duration: 0, adaptive: true },
          pump: 0
        },
        {
          name: "Pump",
          phase: "brew",
          valve: 1,
          duration: 20,
          temperature: 0,
          transition: { type: "instant", duration: 0, adaptive: true },
          pump: 100,
          targets: [
            {
              type: "volumetric",
              operator: "gte",
              value: 36,
              _displayKey: "weight"
            }
          ]
        }
      ]
    };

    function makeDefaultProfile() {
      // deep copy so edits don't mutate the template
      return JSON.parse(JSON.stringify(defaultProfile));
    }

    // DOM references
    const labelInput = document.getElementById("profile-label");
    const typeInput = document.getElementById("profile-type");
    const tempInput = document.getElementById("profile-temp");
    const descInput = document.getElementById("profile-description");
    const utilityInput = document.getElementById("profile-utility");

    const phasesList = document.getElementById("phases-list");
    const addPhaseBtn = document.getElementById("add-phase");
    const resetProfileBtn = document.getElementById("reset-profile");

    const jsonPreview = document.getElementById("json-preview");
    const downloadBtn = document.getElementById("download-json");
    const copyBtn = document.getElementById("copy-json");

    const PhaseTypes = [
      { value: "preinfusion", label: "Preinfusion" },
      { value: "bloom", label: "Bloom" },
      { value: "brew", label: "Brew" },
      { value: "flush", label: "Flush" },
      { value: "other", label: "Other" },
    ];

    // Display modes for the "Stop when" UI
    const TargetDisplayModes = [
      {
        key: "water",
        label: "Water drawn",
        type: "volumetric",
        operator: "gte",
        unit: "ml",
      },
      {
        key: "weight",
        label: "Weight reached",
        type: "volumetric",
        operator: "gte",
        unit: "g",
      },
      {
        key: "pressureAbove",
        label: "Pressure above",
        type: "pressure",
        operator: "gte",
        unit: "bar",
      },
      {
        key: "pressureBelow",
        label: "Pressure below",
        type: "pressure",
        operator: "lte",
        unit: "bar",
      },
      {
        key: "flowAbove",
        label: "Flow above",
        type: "flow",
        operator: "gte",
        unit: "ml/s",
      },
      {
        key: "flowBelow",
        label: "Flow below",
        type: "flow",
        operator: "lte",
        unit: "ml/s",
      },
    ];

    function findModeForTarget(target) {
      if (!target) return TargetDisplayModes[1]; // default to weight

      if (target._displayKey) {
        const byKey = TargetDisplayModes.find(
          (m) => m.key === target._displayKey
        );
        if (byKey) return byKey;
      }

      const byTypeOp = TargetDisplayModes.find(
        (m) => m.type === target.type && m.operator === target.operator
      );
      return byTypeOp || TargetDisplayModes[1];
    }

    let profile = null;
    let chart = null;

    // ---------------------- Pump helpers --------------------------------------
    function getPumpMode(phase) {
      const p = phase.pump;
      if (typeof p === "number") {
        return p === 0 ? "off" : "power";
      }
      if (!p || typeof p !== "object") return "off";
      if (p.target === "flow") return "flow";
      if (p.target === "pressure") return "pressure";
      return "flow";
    }

    function getPumpPressure(phase) {
      const p = phase.pump;
      if (typeof p === "number") {
        // crude mapping for numeric power â†’ pseudo pressure
        return p === 0 ? 0 : Math.round((p / 255) * 9);
      }
      return p && typeof p === "object" && typeof p.pressure === "number"
        ? p.pressure
        : 0;
    }

    function getPumpFlow(phase) {
      const p = phase.pump;
      if (typeof p === "number") return 0;
      return p && typeof p === "object" && typeof p.flow === "number"
        ? p.flow
        : 0;
    }

    function setPump(phase, mode, pressureVal, flowVal, powerVal) {
      const pressure = isNaN(pressureVal) ? 0 : pressureVal;
      const flow = isNaN(flowVal) ? 0 : flowVal;
      const power = isNaN(powerVal) ? 0 : powerVal;

      if (mode === "off") {
        phase.pump = 0;
      } else if (mode === "power") {
        phase.pump = Math.max(0, Math.min(255, power));
      } else if (mode === "flow") {
        phase.pump = {
          target: "flow",
          pressure: pressure,
          flow: flow,
        };
      } else if (mode === "pressure") {
        phase.pump = {
          target: "pressure",
          pressure: pressure,
          flow: flow,
        };
      }
    }

    // -------------------- Rendering: profile fields ---------------------------
    function renderProfileFields() {
      labelInput.value = profile.label || "";
      typeInput.value = profile.type || "pro";
      tempInput.value = profile.temperature ?? 93;
      descInput.value = profile.description || "";
      utilityInput.value = profile.utility ? "true" : "false";
    }

    // ------------------------ Rendering: phases -------------------------------
    function renderPhases() {
      phasesList.innerHTML = "";
      profile.phases.forEach((phase, index) => {
        const mode = getPumpMode(phase);
        const pressure = getPumpPressure(phase);
        const flow = getPumpFlow(phase);
        const transition =
          phase.transition || { type: "instant", duration: 0, adaptive: true };

        const details = document.createElement("details");
        details.className = "phase-card";
        if (index === 0) details.open = true;

        const summary = document.createElement("summary");
        summary.className = "phase-summary";

        const title = document.createElement("div");
        title.className = "phase-title";
        title.textContent = `Phase ${index + 1}: ${phase.name || "Untitled"}`;

        const meta = document.createElement("div");
        meta.className = "phase-meta";
        const m1 = document.createElement("span");
        m1.textContent =
          PhaseTypes.find((t) => t.value === phase.phase)?.label ||
          phase.phase ||
          "Brew";
        const m2 = document.createElement("span");
        m2.textContent = `${Number(phase.duration || 0).toFixed(1)} s`;
        const m3 = document.createElement("span");
        m3.textContent = `Pump: ${mode}`;
        meta.appendChild(m1);
        meta.appendChild(m2);
        meta.appendChild(m3);

        const chevron = document.createElement("span");
        chevron.className = "phase-chevron";
        chevron.textContent = "â€º";

        summary.appendChild(title);
        summary.appendChild(meta);
        summary.appendChild(chevron);

        const body = document.createElement("div");
        body.className = "phase-body";

        // --- Basic settings ---
        const basicSection = document.createElement("div");
        basicSection.className = "phase-section";
        const basicTitle = document.createElement("div");
        basicTitle.className = "phase-section-title";
        basicTitle.textContent = "Basics";
        basicSection.appendChild(basicTitle);

        const basicRow = document.createElement("div");
        basicRow.className = "field-row";

        // Name
        const nameDiv = document.createElement("div");
        const nameLabel = document.createElement("label");
        nameLabel.textContent = "Name";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = phase.name || "";
        nameInput.addEventListener("input", () => {
          phase.name = nameInput.value;
          title.textContent = `Phase ${index + 1}: ${
            phase.name || "Untitled"
          }`;
          updateJsonAndChart();
        });
        nameDiv.appendChild(nameLabel);
        nameDiv.appendChild(nameInput);
        basicRow.appendChild(nameDiv);

        // Type
        const typeDiv = document.createElement("div");
        const typeLabel = document.createElement("label");
        typeLabel.textContent = "Type";
        const typeSelect = document.createElement("select");
        PhaseTypes.forEach((t) => {
          const opt = document.createElement("option");
          opt.value = t.value;
          opt.textContent = t.label;
          if (phase.phase === t.value) opt.selected = true;
          typeSelect.appendChild(opt);
        });
        typeSelect.addEventListener("change", () => {
          phase.phase = typeSelect.value;
          const typeLabelText =
            PhaseTypes.find((t) => t.value === phase.phase)?.label ||
            phase.phase;
          m1.textContent = typeLabelText || "Brew";
          updateJsonAndChart();
        });
        typeDiv.appendChild(typeLabel);
        typeDiv.appendChild(typeSelect);
        basicRow.appendChild(typeDiv);

        // Duration
        const durDiv = document.createElement("div");
        durDiv.className = "field-small";
        const durLabel = document.createElement("label");
        durLabel.textContent = "Dur (s)";
        const durInput = document.createElement("input");
        durInput.type = "number";
        durInput.min = "0";
        durInput.step = "0.1";
        durInput.value = phase.duration ?? 0;
        durInput.addEventListener("input", () => {
          const v = parseFloat(durInput.value);
          phase.duration = isNaN(v) ? 0 : v;
          m2.textContent = `${Number(phase.duration || 0).toFixed(1)} s`;
          updateJsonAndChart();
        });
        durDiv.appendChild(durLabel);
        durDiv.appendChild(durInput);
        basicRow.appendChild(durDiv);

        // Temp override
        const tempDiv = document.createElement("div");
        tempDiv.className = "field-small";
        const tempLabel = document.createElement("label");
        tempLabel.textContent = "Temp (Â°C)";
        const tempInputPhase = document.createElement("input");
        tempInputPhase.type = "number";
        tempInputPhase.min = "0";
        tempInputPhase.step = "0.1";
        tempInputPhase.value = phase.temperature ?? 0;
        tempInputPhase.addEventListener("input", () => {
          const v = parseFloat(tempInputPhase.value);
          phase.temperature = isNaN(v) ? 0 : v;
          updateJsonAndChart();
        });
        tempDiv.appendChild(tempLabel);
        tempDiv.appendChild(tempInputPhase);
        basicRow.appendChild(tempDiv);

        // Valve
        const valveDiv = document.createElement("div");
        valveDiv.className = "field-small";
        const valveLabel = document.createElement("label");
        valveLabel.textContent = "Valve";
        const valveSelect = document.createElement("select");
        const openOpt = document.createElement("option");
        openOpt.value = "1";
        openOpt.textContent = "Open";
        const closedOpt = document.createElement("option");
        closedOpt.value = "0";
        closedOpt.textContent = "Closed";
        valveSelect.appendChild(openOpt);
        valveSelect.appendChild(closedOpt);
        valveSelect.value = String(phase.valve ?? 1);
        valveSelect.addEventListener("change", () => {
          phase.valve = parseInt(valveSelect.value, 10) || 0;
          updateJsonAndChart();
        });
        valveDiv.appendChild(valveLabel);
        valveDiv.appendChild(valveSelect);
        basicRow.appendChild(valveDiv);

        basicSection.appendChild(basicRow);
        body.appendChild(basicSection);

        // --- Pump settings ---
        const pumpSection = document.createElement("div");
        pumpSection.className = "phase-section";
        const pumpTitle = document.createElement("div");
        pumpTitle.className = "phase-section-title";
        pumpTitle.textContent = "Pump";
        pumpSection.appendChild(pumpTitle);

        const pumpRow = document.createElement("div");
        pumpRow.className = "field-row";

        const modeDiv = document.createElement("div");
        modeDiv.className = "field-small";
        const modeLabel = document.createElement("label");
        modeLabel.textContent = "Mode";
        const pumpModeSelect = document.createElement("select");
        [
          { value: "off", label: "Off" },
          { value: "power", label: "Power (0-255)" },
          { value: "flow", label: "Flow target" },
          { value: "pressure", label: "Pressure target" },
        ].forEach((optCfg) => {
          const opt = document.createElement("option");
          opt.value = optCfg.value;
          opt.textContent = optCfg.label;
          if (mode === optCfg.value) opt.selected = true;
          pumpModeSelect.appendChild(opt);
        });
        modeDiv.appendChild(modeLabel);
        modeDiv.appendChild(pumpModeSelect);
        pumpRow.appendChild(modeDiv);

        const pressureDiv = document.createElement("div");
        pressureDiv.className = "field-small";
        const pressureLabel = document.createElement("label");
        pressureLabel.textContent = "Pressure (bar / power)";
        const pressureInput = document.createElement("input");
        pressureInput.type = "number";
        pressureInput.step = "0.1";
        pressureInput.value =
          mode === "power" && typeof phase.pump === "number"
            ? phase.pump
            : pressure;
        pressureDiv.appendChild(pressureLabel);
        pressureDiv.appendChild(pressureInput);
        pumpRow.appendChild(pressureDiv);

        const flowDiv = document.createElement("div");
        flowDiv.className = "field-small";
        const flowLabel = document.createElement("label");
        flowLabel.textContent = "Flow (ml/s)";
        const flowInput = document.createElement("input");
        flowInput.type = "number";
        flowInput.step = "0.1";
        flowInput.value = flow;
        flowDiv.appendChild(flowLabel);
        flowDiv.appendChild(flowInput);
        pumpRow.appendChild(flowDiv);

        pumpSection.appendChild(pumpRow);
        body.appendChild(pumpSection);

        const syncPump = () => {
          const modeVal = pumpModeSelect.value;
          const pVal = parseFloat(pressureInput.value);
          const fVal = parseFloat(flowInput.value);
          const powerVal = parseFloat(pressureInput.value); // reused
          setPump(phase, modeVal, pVal, fVal, powerVal);

          const newMode = getPumpMode(phase);
          m3.textContent = `Pump: ${newMode}`;

          updateJsonAndChart();
        };
        pumpModeSelect.addEventListener("change", syncPump);
        pressureInput.addEventListener("input", syncPump);
        flowInput.addEventListener("input", syncPump);

        // --- Transition ---
        const transSection = document.createElement("div");
        transSection.className = "phase-section";
        const transTitle = document.createElement("div");
        transTitle.className = "phase-section-title";
        transTitle.textContent = "Transition to next phase";
        transSection.appendChild(transTitle);

        const transRow = document.createElement("div");
        transRow.className = "field-row";

        const typeDivTrans = document.createElement("div");
        const typeLabelTrans = document.createElement("label");
        typeLabelTrans.textContent = "Type";
        const transTypeSelect = document.createElement("select");
        ["instant", "linear", "ease-in", "ease-out", "ease-in-out"].forEach(
          (t) => {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t;
            if (transition.type === t) opt.selected = true;
            transTypeSelect.appendChild(opt);
          }
        );
        transTypeSelect.addEventListener("change", () => {
          phase.transition = phase.transition || {};
          phase.transition.type = transTypeSelect.value;
          updateJsonAndChart();
        });
        typeDivTrans.appendChild(typeLabelTrans);
        typeDivTrans.appendChild(transTypeSelect);
        transRow.appendChild(typeDivTrans);

        const durDivTrans = document.createElement("div");
        durDivTrans.className = "field-small";
        const durLabelTrans = document.createElement("label");
        durLabelTrans.textContent = "Duration (s)";
        const transDurationInput = document.createElement("input");
        transDurationInput.type = "number";
        transDurationInput.min = "0";
        transDurationInput.step = "0.1";
        transDurationInput.value = transition.duration ?? 0;
        transDurationInput.addEventListener("input", () => {
          const v = parseFloat(transDurationInput.value);
          phase.transition = phase.transition || {};
          phase.transition.duration = isNaN(v) ? 0 : v;
          updateJsonAndChart();
        });
        durDivTrans.appendChild(durLabelTrans);
        durDivTrans.appendChild(transDurationInput);
        transRow.appendChild(durDivTrans);

        const adaptDiv = document.createElement("div");
        adaptDiv.className = "field-small";
        const adaptLabel = document.createElement("label");
        adaptLabel.textContent = "Adaptive?";
        const transAdaptiveSelect = document.createElement("select");
        ["true", "false"].forEach((v) => {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          if ((transition.adaptive ? "true" : "false") === v) {
            opt.selected = true;
          }
          transAdaptiveSelect.appendChild(opt);
        });
        transAdaptiveSelect.addEventListener("change", () => {
          phase.transition = phase.transition || {};
          phase.transition.adaptive = transAdaptiveSelect.value === "true";
          updateJsonAndChart();
        });
        adaptDiv.appendChild(adaptLabel);
        adaptDiv.appendChild(transAdaptiveSelect);
        transRow.appendChild(adaptDiv);

        transSection.appendChild(transRow);
        body.appendChild(transSection);

        // --- Stop when (targets) ---
        const targetsSection = document.createElement("div");
        targetsSection.className = "phase-section";

        const headerRow = document.createElement("div");
        headerRow.className = "targets-header-row";

        const targetsTitle = document.createElement("div");
        targetsTitle.className = "phase-section-title";
        targetsTitle.textContent = "Stop when";
        headerRow.appendChild(targetsTitle);

        const addTargetBtn = document.createElement("button");
        addTargetBtn.className = "btn btn-sm";
        addTargetBtn.type = "button";
        addTargetBtn.textContent = "+";
        headerRow.appendChild(addTargetBtn);

        targetsSection.appendChild(headerRow);

        const targetsContainer = document.createElement("div");
        targetsContainer.className = "targets-container";
        targetsSection.appendChild(targetsContainer);

        const helpText = document.createElement("div");
        helpText.className = "targets-help";
        helpText.textContent =
          "All conditions are combined with OR: the phase stops when any is met.";
        targetsSection.appendChild(helpText);

        function renderTargetsForPhase() {
          const targets = phase.targets || [];
          targetsContainer.innerHTML = "";

          if (!targets.length) {
            const empty = document.createElement("div");
            empty.className = "targets-help";
            empty.textContent =
              "No stop targets. Phase will stop only when its duration ends.";
            targetsContainer.appendChild(empty);
            return;
          }

          targets.forEach((target, tIndex) => {
            const modeForTarget = findModeForTarget(target);
            target.type = modeForTarget.type;
            target.operator = modeForTarget.operator;
            target._displayKey = modeForTarget.key;

            const row = document.createElement("div");
            row.className = "target-row";

            const rowHeader = document.createElement("div");
            rowHeader.className = "target-row-header";

            const condLabel = document.createElement("label");
            condLabel.textContent = "Condition";
            rowHeader.appendChild(condLabel);

            const condSelect = document.createElement("select");
            TargetDisplayModes.forEach((m) => {
              const opt = document.createElement("option");
              opt.value = m.key;
              opt.textContent = m.label;
              if (m.key === modeForTarget.key) opt.selected = true;
              condSelect.appendChild(opt);
            });
            rowHeader.appendChild(condSelect);

            const delBtn = document.createElement("button");
            delBtn.className = "btn btn-sm btn-danger";
            delBtn.type = "button";
            delBtn.textContent = "âœ•";
            delBtn.addEventListener("click", () => {
              phase.targets.splice(tIndex, 1);
              renderTargetsForPhase();
              updateJsonAndChart();
            });
            rowHeader.appendChild(delBtn);

            row.appendChild(rowHeader);

            const rowBody = document.createElement("div");
            rowBody.className = "target-row-body";

            const valueLabel = document.createElement("label");
            valueLabel.textContent = "Value";
            rowBody.appendChild(valueLabel);

            const valueWrap = document.createElement("div");
            valueWrap.className = "target-value-wrap";

            const valInput = document.createElement("input");
            valInput.type = "number";
            valInput.step = "0.1";
            valInput.value =
              typeof target.value === "number" ? target.value : 0;
            valInput.addEventListener("input", () => {
              const v = parseFloat(valInput.value);
              target.value = isNaN(v) ? 0 : v;
              updateJsonAndChart();
            });
            valueWrap.appendChild(valInput);

            const unitSpan = document.createElement("span");
            unitSpan.className = "target-unit";
            unitSpan.textContent = modeForTarget.unit;
            valueWrap.appendChild(unitSpan);

            rowBody.appendChild(valueWrap);
            row.appendChild(rowBody);

            condSelect.addEventListener("change", () => {
              const selectedMode =
                TargetDisplayModes.find((m) => m.key === condSelect.value) ||
                TargetDisplayModes[1];
              target._displayKey = selectedMode.key;
              target.type = selectedMode.type;
              target.operator = selectedMode.operator;
              unitSpan.textContent = selectedMode.unit;
              updateJsonAndChart();
            });

            targetsContainer.appendChild(row);

            if (tIndex < targets.length - 1) {
              const orDivider = document.createElement("div");
              orDivider.className = "target-or";
              orDivider.innerHTML =
                '<span class="target-or-line"></span><span class="target-or-text">OR</span><span class="target-or-line"></span>';
              targetsContainer.appendChild(orDivider);
            }
          });
        }

        renderTargetsForPhase();

        addTargetBtn.addEventListener("click", () => {
          phase.targets = phase.targets || [];
          phase.targets.push({
            type: "volumetric",
            operator: "gte",
            value: 30,
            _displayKey: "weight",
          });
          renderTargetsForPhase();
          updateJsonAndChart();
        });

        body.appendChild(targetsSection);

        // Delete phase button
        const deleteRow = document.createElement("div");
        deleteRow.className = "btn-row";
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn btn-sm btn-danger";
        deleteBtn.type = "button";
        deleteBtn.textContent = "Delete phase";
        deleteBtn.addEventListener("click", () => {
          profile.phases.splice(index, 1);
          renderPhases();
          updateJsonAndChart();
        });
        deleteRow.appendChild(deleteBtn);
        body.appendChild(deleteRow);

        details.appendChild(summary);
        details.appendChild(body);
        phasesList.appendChild(details);
      });
    }

    // --------------------------- JSON & chart ---------------------------------
    function buildExportJson() {
      const exportProfile = JSON.parse(JSON.stringify(profile));
      // strip UI-only keys
      if (exportProfile.phases) {
        exportProfile.phases.forEach((p) => {
          (p.targets || []).forEach((t) => {
            delete t._displayKey;
          });
        });
      }
      delete exportProfile.id;
      delete exportProfile.selected;
      delete exportProfile.favorite;
      return exportProfile;
    }

    function updateJsonPreview() {
      const exportProfile = buildExportJson();
      jsonPreview.value = JSON.stringify(exportProfile, null, 2);
    }

    // Easing helpers for transitions
    function easeProgress(type, r) {
      r = Math.max(0, Math.min(1, r));
      switch (type) {
        case "linear":
          return r;
        case "ease-in":
          return r * r; // quadratic ease-in
        case "ease-out":
          return 1 - (1 - r) * (1 - r); // quadratic ease-out
        case "ease-in-out":
          return r < 0.5
            ? 2 * r * r
            : 1 - 2 * (1 - r) * (1 - r); // smooth-ish
        default:
          return r; // treat unknown like linear
      }
    }

    function updateChart() {
      const canvas = document.getElementById("profile-chart");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");

      const phases = profile.phases || [];
      if (!phases.length) return;

      // Precompute phase start times and total time
      const phaseStartTimes = [];
      let totalTime = 0;
      phases.forEach((p, i) => {
        phaseStartTimes[i] = totalTime;
        totalTime += Number(p.duration) || 0;
      });

      const timeStep = 0.25; // finer step so easing curves look smooth
      const labels = [];
      const pressureData = [];
      const flowData = [];
      const tempData = [];

      for (let t = 0; t <= totalTime + 1e-6; t += timeStep) {
        const rounded = Math.round(t);
        labels.push(rounded % 5 === 0 ? rounded : "");

        // Find which phase we're in at time t
        let phaseIndex = phases.length - 1;
        let phaseStart = phaseStartTimes[phaseIndex];
        let phaseEnd =
          phaseStart + (Number(phases[phaseIndex].duration) || 0);

        for (let i = 0; i < phases.length; i++) {
          const start = phaseStartTimes[i];
          const end = start + (Number(phases[i].duration) || 0);
          if (t >= start && t <= end + 1e-6) {
            phaseIndex = i;
            phaseStart = start;
            phaseEnd = end;
            break;
          }
        }

        const phase = phases[phaseIndex];
        const basePressure = getPumpPressure(phase);
        const baseFlow = getPumpFlow(phase);

        let pressure = basePressure;
        let flow = baseFlow;

        // Transition belongs to this phase: ease from PREVIOUS phase into THIS phase
        const transition =
          phase.transition || { type: "instant", duration: 0, adaptive: true };
        const transDuration = Number(transition.duration) || 0;

        if (
          phaseIndex > 0 &&
          transition.type &&
          transition.type !== "instant" &&
          transDuration > 0
        ) {
          const rampStart = phaseStart;
          const rampEnd = Math.min(rampStart + transDuration, phaseEnd);

          if (t >= rampStart && t <= rampEnd + 1e-6) {
            const prevPhase = phases[phaseIndex - 1];
            const prevPressure = getPumpPressure(prevPhase);
            const prevFlow = getPumpFlow(prevPhase);

            const rawR = (t - rampStart) / (rampEnd - rampStart || 1);
            const easedR = easeProgress(transition.type, rawR);

            // interpolate from prev â†’ current
            pressure =
              prevPressure + (basePressure - prevPressure) * easedR;
            flow = prevFlow + (baseFlow - prevFlow) * easedR;
          }
        }

        const effectiveTemp =
          typeof phase.temperature === "number" && phase.temperature !== 0
            ? phase.temperature
            : profile.temperature;

        pressureData.push(pressure);
        flowData.push(flow);
        tempData.push(effectiveTemp);
      }

      const chartData = {
        labels,
        datasets: [
          {
            label: "Pressure (bar)",
            data: pressureData,
            yAxisID: "y1",
            tension: 0,
            borderWidth: 2,
            pointRadius: 0,
            pointHitRadius: 6,
          },
          {
            label: "Flow (ml/s)",
            data: flowData,
            yAxisID: "y2",
            tension: 0,
            borderWidth: 2,
            pointRadius: 0,
            pointHitRadius: 6,
          },
          {
            label: "Temperature (Â°C)",
            data: tempData,
            yAxisID: "yTemp",
            tension: 0,
            borderDash: [4, 3],
            borderWidth: 2,
            pointRadius: 0,
            pointHitRadius: 6,
          },
        ],
      };

      if (!chart) {
        chart = new Chart(ctx, {
          type: "line",
          data: chartData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                labels: {
                  color: "#e5e7eb",
                  font: { size: 10 },
                },
              },
              tooltip: {
                mode: "index",
                intersect: false,
              },
            },
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Time (s)",
                  color: "#9ca3af",
                },
                ticks: { color: "#9ca3af" },
                grid: { color: "#111827" },
              },
              y1: {
                position: "left",
                title: {
                  display: true,
                  text: "Pressure (bar)",
                  color: "#9ca3af",
                },
                ticks: { color: "#9ca3af" },
                grid: { color: "#111827" },
                suggestedMin: 0,
                suggestedMax: 10,
              },
              y2: {
                position: "right",
                title: {
                  display: true,
                  text: "Flow (ml/s)",
                  color: "#9ca3af",
                },
                ticks: { color: "#9ca3af" },
                grid: { display: false },
                suggestedMin: 0,
                suggestedMax: 8,
              },
              yTemp: {
                position: "right",
                offset: true,
                title: {
                  display: true,
                  text: "Temperature (Â°C)",
                  color: "#9ca3af",
                },
                ticks: { color: "#9ca3af" },
                grid: { display: false },
                suggestedMin: 80,
                suggestedMax: 105,
              },
            },
          },
        });
      } else {
        chart.data = chartData;
        chart.update();
      }
    }

    function updateJsonAndChart() {
      updateJsonPreview();
      updateChart();
    }

    // ---------------------------- Event wiring --------------------------------
    labelInput.addEventListener("input", () => {
      profile.label = labelInput.value;
      updateJsonAndChart();
    });

    typeInput.addEventListener("change", () => {
      profile.type = typeInput.value || "pro";
      updateJsonAndChart();
    });

    tempInput.addEventListener("input", () => {
      const v = parseFloat(tempInput.value);
      profile.temperature = isNaN(v) ? 93 : v;
      updateJsonAndChart();
    });

    descInput.addEventListener("input", () => {
      profile.description = descInput.value;
      updateJsonAndChart();
    });

    utilityInput.addEventListener("change", () => {
      profile.utility = utilityInput.value === "true";
      updateJsonAndChart();
    });

    addPhaseBtn.addEventListener("click", () => {
      profile.phases.push({
        name: "New phase",
        phase: "brew",
        valve: 1,
        duration: 10,
        temperature: 0,
        transition: { type: "instant", duration: 0, adaptive: true },
        pump: 0,
        targets: [],
      });
      renderPhases();
      updateJsonAndChart();
    });

    resetProfileBtn.addEventListener("click", () => {
      profile = makeDefaultProfile();
      renderProfileFields();
      renderPhases();
      updateJsonAndChart();
    });

    downloadBtn.addEventListener("click", () => {
      const exportProfile = buildExportJson();
      const jsonStr = JSON.stringify(exportProfile, null, 2);
      const blob = new Blob([jsonStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const safeLabel =
        (exportProfile.label || "profile")
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-|-$/g, "") || "profile";
      const a = document.createElement("a");
      a.href = url;
      a.download = `${safeLabel}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    copyBtn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(jsonPreview.value);
        copyBtn.textContent = "âœ… Copied!";
        setTimeout(() => {
          copyBtn.textContent = "ðŸ“‹ Copy JSON";
        }, 1600);
      } catch (e) {
        copyBtn.textContent = "âŒ Error";
        setTimeout(() => {
          copyBtn.textContent = "ðŸ“‹ Copy JSON";
        }, 1600);
      }
    });

    // ------------------------------- Init -------------------------------------
    window.addEventListener("DOMContentLoaded", () => {
      profile = makeDefaultProfile();
      renderProfileFields();
      renderPhases();
      updateJsonAndChart();
    });
  </script>
</body>
</html>
